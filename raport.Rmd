---
title: "Raport_ZED"
author: "Jedrzej Karpiewski"
date: "11 stycznia 2016"
output:
  html_document:
    keep_md: yes
  pdf_document: default
---
```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(dplyr)
library(ggplot2)
```
Na pocz¹tku pliku powinna znajdowaæ siê automatycznie wype³niona data generacji dokumentu oraz spis treœci pozwalaj¹cy przejœæ do najwa¿niejszych sekcji. Ponadto raport powinien zaczynaæ siê od rozdzia³u podsumowuj¹cego ca³¹ analizê, streszczaj¹cego najwa¿niejsze zauwa¿one rzeczy. Po wstêpie, raport powinien zawieraæ nastêpuj¹ce elementy:

1. Kod wyliczaj¹cy wykorzystane biblioteki;
```{r}
search()
```
2.Kod zapewniaj¹cy powtarzalnoœæ wyników przy ka¿dym uruchomieniu raportu na tych samych danych;

-cache???

3.Kod pozwalaj¹cy wczytaæ dane z pliku;
```{r}
data <- read.csv(file="1000.txt",head=TRUE,sep=";")
```
4. Kod usuwaj¹cy z danych wiersze posiadaj¹ce wartoœæ zmiennej res_name równ¹: “DA”,“DC”,“DT”, “DU”, “DG”, “DI”,“UNK”, “UNX”, “UNL”, “PR”, “PD”, “Y1”, “EU”, “N”, “15P”, “UQ”, “PX4” lub “NAN”;
```{r}
data <- filter(data, res_name != "DA", res_name != "DC",res_name != "DT", res_name != "DU", res_name != "DG", res_name != "DI",res_name != "UNK", res_name != "UNX", res_name != "UNL", res_name != "PR", res_name != "PD", res_name != "Y1", res_name != "EU", res_name != "N", res_name != "15P", res_name != "UQ", res_name != "PX4",res_name != "NAN")
```
5.Kod pozostawiaj¹cy tylko unikatowe pary wartoœci (pdb_code, res_name)
```{r}
clean_data <- distinct(data, pdb_code, res_name)
#head(clean_data, 10)
```
6.Krótkie podsumowanie wartoœci w ka¿dej kolumnie;
```{r}
# knitr::kable(summary(data))
# summary(data)
```

7.Sekcje sprawdzaj¹c¹ korelacje miêdzy zmiennymi; sekcja ta powinna zawieraæ jak¹œ formê graficznej prezentacji korelacji;
```{r}
#wykonaæ funkcjê cor() na wszystkich parach kolumn "zielonych"
#pocisnac te kolumny foreachem?
```

8.Okreœlenie ile przyk³adów ma ka¿da z klas (res_name);
```{r}
count_data <- count(clean_data, res_name)
arrange(count_data, desc(n))
```

9.Wykresy rozk³adów liczby atomów (local_res_atom_non_h_count) i elektronów (local_res_atom_non_h_electron_sum);
```{r}
atoms_data <- count(clean_data, local_res_atom_non_h_count)
#atoms_data
ggplot(atoms_data, 
  mapping=aes(
      x=local_res_atom_non_h_count, 
      y=n) 
) + geom_bar(stat="identity") + xlab("Liczba atomów") + ylab("Krotnoœæ wystêpowania") 
  #+
  #scale_x_continuous(breaks = seq(0, 30, 1)) +
  #scale_y_continuous(breaks = seq(0, 30, 1))

electrons_data <- count(clean_data, local_res_atom_non_h_electron_sum)
#electrons_data
ggplot(electrons_data, 
  mapping=aes(
      x=local_res_atom_non_h_electron_sum, 
      y=n) 
) + geom_bar(stat="identity") + xlab("Liczba elektronów") + ylab("Krotnoœæ wystêpowania") 
  #+
  #scale_x_continuous(breaks = seq(0, 30, 1)) +
  #scale_y_continuous(breaks = seq(0, 30, 1))
```

10.Próbê odtworzenia nastêpuj¹cego wykresu (oœ X - liczba elektronów, oœ y - liczba atomów): 


11.Tabelê pokazuj¹c¹ 10 klas z najwiêksz¹ niezgodnoœci¹ liczby atomów (local_res_atom_non_h_count vs dict_atom_non_h_count) i tabelê pokazuj¹c¹ 10 klas z najwiêksz¹ niezgodnoœci¹ liczby elektronów (local_res_atom_non_h_electron_sum vs dict_atom_non_h_electron_sum;)

```{r}
diff_between_expected_atoms <- select(clean_data, res_name, local_res_atom_non_h_count, dict_atom_non_h_count) %>%
mutate(diff = abs(local_res_atom_non_h_count - dict_atom_non_h_count), diff_squared = diff*diff) %>%
group_by(res_name) %>% 
  summarize(difference_mean = mean(diff), standard_deviation = sqrt(mean(diff_squared))) %>%
  arrange(desc(standard_deviation),desc(difference_mean))

knitr::kable(head(diff_between_expected_atoms,10), col.names = c("Nazwa ligandu","Œrednia ró¿nica od wartoœci oczekiwanej","Odchylenie standardowe"), caption = "Tabela przedstawiaj¹ca 10 klas z najwiêksz¹ niezgodnoœci¹ liczby atomów (sort po odchyleniu standardowym).")
```

```{r}
diff_between_expected_electrons <- select(clean_data, res_name, local_res_atom_non_h_electron_sum, dict_atom_non_h_electron_sum) %>%
mutate(diff = abs(local_res_atom_non_h_electron_sum - dict_atom_non_h_electron_sum), diff_squared = diff*diff) %>%
group_by(res_name) %>% 
  summarize(difference_mean = mean(diff), standard_deviation = sqrt(mean(diff_squared))) %>%
  arrange(desc(standard_deviation),desc(difference_mean))

knitr::kable(head(diff_between_expected_electrons,10), col.names = c("Nazwa ligandu","Œrednia ró¿nica od wartoœci oczekiwanej","Odchylenie standardowe"), caption = "Tabela przedstawiaj¹ca 10 klas z najwiêksz¹ niezgodnoœci¹ liczby elektronów (sort po odchyleniu standardowym).")
```

12.Sekcjê pokazuj¹c¹ rozk³ad wartoœci wszystkich kolumn zaczynaj¹cych siê od part_01 z zaznaczeniem (graficznym i liczbowym) œredniej wartoœci;

13.Sekcjê sprawdzaj¹c¹ czy na podstawie wartoœci innych kolumn mo¿na przewidzieæ liczbê elektronów i atomów oraz z jak¹ dok³adnoœci¹ mo¿na dokonaæ takiej predykcji; trafnoœæ regresji powinna zostaæ oszacowana na podstawie miar R^2 i RMSE;

14.Sekcjê próbuj¹c¹ stworzyæ klasyfikator przewiduj¹cy wartoœæ atrybutu res_name (w tej sekcji nale¿y wykorzystaæ wiedzê z pozosta³ych punktów oraz wykonaæ dodatkowe czynnoœci, które mog¹ poprawiæ trafnoœæ klasyfikacji); klasyfikator powinien byæ wybrany w ramach optymalizacji parametrów na zbiorze waliduj¹cym; przewidywany b³¹d na danych z reszty populacji powinien zostaæ oszacowany na danych inne ni¿ ucz¹ce za pomoc¹ mechanizmu (stratyfikowanej!) oceny krzy¿owej lub (stratyfikowanego!) zbioru testowego.